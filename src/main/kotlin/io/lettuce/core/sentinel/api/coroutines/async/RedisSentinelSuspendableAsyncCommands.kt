/*
 * Copyright 2017-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("unused")

package io.lettuce.core.sentinel.api.coroutines.async

import kotlinx.coroutines.future.await
import io.lettuce.core.api.coroutines.*
import io.lettuce.core.sentinel.api.coroutines.*
import io.lettuce.core.api.async.*
import io.lettuce.core.sentinel.api.async.*
import io.lettuce.core.ExperimentalLettuceCoroutinesApi
import java.net.SocketAddress
import io.lettuce.core.KillArgs
import io.lettuce.core.sentinel.api.StatefulRedisSentinelConnection


/**
 * Coroutine executed commands (based on async commands) for Redis Sentinel.
 * 
 * @param <K> Key type.
 * @param <V> Value type.
 * @author Mikhael Sokolov
 * @since 6.0
 * 
 * @generated by io.lettuce.apigenerator.CreateKotlinCoroutinesAsyncImplementation
 **/
@ExperimentalLettuceCoroutinesApi
internal class RedisSentinelSuspendableAsyncCommands<K, V>(private val ops: RedisSentinelAsyncCommands<K, V>) : RedisSentinelSuspendableCommands<K, V> {

    /**
     * Return the ip and port number of the master with that name.
     * 
     * @param key the key.
     * @return SocketAddress;.
     * 
     **/
    override suspend fun getMasterAddrByName(key: K?): SocketAddress? = ops.getMasterAddrByName(key).await()

    /**
     * Enumerates all the monitored masters and their states.
     * 
     * @return Map<K, V>>.
     * 
     **/
    override suspend fun masters(): List<Map<K, V>>? = ops.masters().await()

    /**
     * Show the state and info of the specified master.
     * 
     * @param key the key.
     * @return Map<K, V>.
     * 
     **/
    override suspend fun master(key: K?): Map<K, V>? = ops.master(key).await()

    /**
     * Provides a list of replicas for the master with the specified name.
     * 
     * @param key the key.
     * @return List<Map<K, V>>.
     * 
     **/
    override suspend fun slaves(key: K?): List<Map<K, V>>? = ops.slaves(key).await()

    /**
     * This command will reset all the masters with matching name.
     * 
     * @param key the key.
     * @return Long.
     * 
     **/
    override suspend fun reset(key: K?): Long? = ops.reset(key).await()

    /**
     * Perform a failover.
     * 
     * @param key the master id.
     * @return String.
     * 
     **/
    override suspend fun failover(key: K?): String? = ops.failover(key).await()

    /**
     * This command tells the Sentinel to start monitoring a new master with the specified name, ip, port, and quorum.
     * 
     * @param key the key.
     * @param ip the IP address.
     * @param port the port.
     * @param quorum the quorum count.
     * @return String.
     * 
     **/
    override suspend fun monitor(key: K?, ip: String?, port: Int, quorum: Int): String? = ops.monitor(key, ip, port, quorum).await()

    /**
     * Multiple option / value pairs can be specified (or none at all).
     * 
     * @param key the key.
     * @param option the option.
     * @param value the value.
     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
     * 
     **/
    override suspend fun set(key: K?, option: String?, value: V?): String? = ops.set(key, option, value).await()

    /**
     * remove the specified master.
     * 
     * @param key the key.
     * @return String.
     * 
     **/
    override suspend fun remove(key: K?): String? = ops.remove(key).await()

    /**
     * Get the current connection name.
     * 
     * @return K bulk-string-reply The connection name, or a null bulk reply if no name is set.
     * 
     **/
    override suspend fun clientGetname(): K? = ops.clientGetname().await()

    /**
     * Set the current connection name.
     * 
     * @param name the client name.
     * @return simple-string-reply {@code OK} if the connection name was successfully set.
     * 
     **/
    override suspend fun clientSetname(name: K?): String? = ops.clientSetname(name).await()

    /**
     * Kill the connection of a client identified by ip:port.
     * 
     * @param addr ip:port.
     * @return String simple-string-reply {@code OK} if the connection exists and has been closed.
     * 
     **/
    override suspend fun clientKill(addr: String?): String? = ops.clientKill(addr).await()

    /**
     * Kill connections of clients which are filtered by {@code killArgs}.
     * 
     * @param killArgs args for the kill operation.
     * @return Long integer-reply number of killed connections.
     * 
     **/
    override suspend fun clientKill(killArgs: KillArgs?): Long? = ops.clientKill(killArgs).await()

    /**
     * Stop processing commands from clients for some time.
     * 
     * @param timeout the timeout value in milliseconds.
     * @return String simple-string-reply The command returns OK or an error if the timeout is invalid.
     * 
     **/
    override suspend fun clientPause(timeout: Long): String? = ops.clientPause(timeout).await()

    /**
     * Get the list of client connections.
     * 
     * @return String bulk-string-reply a unique string, formatted as follows: One client connection per line (separated by LF),
     *         each line is composed of a succession of property=value fields separated by a space character.
     * 
     **/
    override suspend fun clientList(): String? = ops.clientList().await()

    /**
     * Get information and statistics about the server.
     * 
     * @return String bulk-string-reply as a collection of text lines.
     * 
     **/
    override suspend fun info(): String? = ops.info().await()

    /**
     * Get information and statistics about the server.
     * 
     * @param section the section type: string.
     * @return String bulk-string-reply as a collection of text lines.
     * 
     **/
    override suspend fun info(section: String?): String? = ops.info(section).await()

    /**
     * Ping the server.
     * 
     * @return String simple-string-reply.
     * 
     **/
    override suspend fun ping(): String? = ops.ping().await()

    /**
     * 
     * @return @code true} if the connection is open (connected and not closed).
     * 
     **/
    override suspend fun isOpen(): Boolean = ops.isOpen()

    /**
     * 
     * @return the underlying connection.
     * 
     **/
    override suspend fun getStatefulConnection(): StatefulRedisSentinelConnection<K, V>? = ops.getStatefulConnection()

}


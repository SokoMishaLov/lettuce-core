/*
 * Copyright 2017-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("unused")

package io.lettuce.core.api.coroutines.async

import kotlinx.coroutines.future.await
import io.lettuce.core.api.coroutines.*
import io.lettuce.core.sentinel.api.coroutines.*
import io.lettuce.core.api.async.*
import io.lettuce.core.sentinel.api.async.*
import io.lettuce.core.ExperimentalLettuceCoroutinesApi
import io.lettuce.core.protocol.CommandArgs
import io.lettuce.core.protocol.ProtocolKeyword
import io.lettuce.core.output.CommandOutput


/**
 * Coroutine executed commands (based on async commands) for basic commands.
 * 
 * @param <K> Key type.
 * @param <V> Value type.
 * @author Mikhael Sokolov
 * @since 6.0
 * 
 * @generated by io.lettuce.apigenerator.CreateKotlinCoroutinesAsyncImplementation
 **/
@ExperimentalLettuceCoroutinesApi
internal class BaseRedisSuspendableAsyncCommands<K, V>(private val ops: BaseRedisAsyncCommands<K, V>) : BaseRedisSuspendableCommands<K, V> {

    /**
     * Post a message to a channel.
     * 
     * @param channel the channel type: key.
     * @param message the message type: value.
     * @return Long integer-reply the number of clients that received the message.
     * 
     **/
    override suspend fun publish(channel: K?, message: V?): Long? = ops.publish(channel, message).await()

    /**
     * Lists the currently *active channels*.
     * 
     * @return List<K> array-reply a list of active channels, optionally matching the specified pattern.
     * 
     **/
    override suspend fun pubsubChannels(): List<K>? = ops.pubsubChannels().await()

    /**
     * Lists the currently *active channels*.
     * 
     * @param channel the key.
     * @return List<K> array-reply a list of active channels, optionally matching the specified pattern.
     * 
     **/
    override suspend fun pubsubChannels(channel: K?): List<K>? = ops.pubsubChannels(channel).await()

    /**
     * Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.
     * 
     * @param channels channel keys.
     * @return array-reply a list of channels and number of subscribers for every channel.
     * 
     **/
    override suspend fun pubsubNumsub(vararg channels: K?): Map<K, Long>? = ops.pubsubNumsub(*channels).await()

    /**
     * Returns the number of subscriptions to patterns.
     * 
     * @return Long integer-reply the number of patterns all the clients are subscribed to.
     * 
     **/
    override suspend fun pubsubNumpat(): Long? = ops.pubsubNumpat().await()

    /**
     * Echo the given string.
     * 
     * @param msg the message type: value.
     * @return V bulk-string-reply.
     * 
     **/
    override suspend fun echo(msg: V?): V? = ops.echo(msg).await()

    /**
     * Return the role of the instance in the context of replication.
     * 
     * @return List<Object> array-reply where the first element is one of master, slave, sentinel and the additional
     *         elements are role-specific.
     * 
     **/
    override suspend fun role(): List<Any>? = ops.role().await()

    /**
     * Ping the server.
     * 
     * @return String simple-string-reply.
     * 
     **/
    override suspend fun ping(): String? = ops.ping().await()

    /**
     * Switch connection to Read-Only mode when connecting to a cluster.
     * 
     * @return String simple-string-reply.
     * 
     **/
    override suspend fun readOnly(): String? = ops.readOnly().await()

    /**
     * Switch connection to Read-Write mode (default) when connecting to a cluster.
     * 
     * @return String simple-string-reply.
     * 
     **/
    override suspend fun readWrite(): String? = ops.readWrite().await()

    /**
     * Instructs Redis to disconnect the connection. Note that if auto-reconnect is enabled then Lettuce will auto-reconnect if
     * the connection was disconnected. Use {@link io.lettuce.core.api.StatefulConnection#close} to close connections and
     * release resources.
     * 
     * @return String simple-string-reply always OK.
     * 
     **/
    override suspend fun quit(): String? = ops.quit().await()

    /**
     * Wait for replication.
     * 
     * @param replicas minimum number of replicas.
     * @param timeout timeout in milliseconds.
     * @return number of replicas.
     * 
     **/
    override suspend fun waitForReplication(replicas: Int, timeout: Long): Long? = ops.waitForReplication(replicas, timeout).await()

    /**
     * Dispatch a command to the Redis Server. Please note the command output type must fit to the command response.
     * 
     * @param type the command, must not be {@code null}.
     * @param output the command output, must not be {@code null}.
     * @param <T> response type.
     * @return the command response.
     * 
     **/
    override suspend fun <T> dispatch(type: ProtocolKeyword?, output: CommandOutput<K, V, T>?): T? = ops.dispatch<T>(type, output).await()

    /**
     * Dispatch a command to the Redis Server. Please note the command output type must fit to the command response.
     * 
     * @param type the command, must not be {@code null}.
     * @param output the command output, must not be {@code null}.
     * @param args the command arguments, must not be {@code null}.
     * @param <T> response type.
     * @return the command response.
     * 
     **/
    override suspend fun <T> dispatch(type: ProtocolKeyword?, output: CommandOutput<K, V, T>?, args: CommandArgs<K, V>?): T? = ops.dispatch<T>(type, output, args).await()

    /**
     * 
     * @return @code true} if the connection is open (connected and not closed).
     * 
     **/
    override suspend fun isOpen(): Boolean = ops.isOpen()

    /**
     * Reset the command state. Queued commands will be canceled and the internal state will be reset. This is useful when the
     * internal state machine gets out of sync with the connection.
     * 
     **/
    override suspend fun reset(): Unit? = ops.reset()

    /**
     * Disable or enable auto-flush behavior. Default is {@code true}. If autoFlushCommands is disabled, multiple commands can
     * be issued without writing them actually to the transport. Commands are buffered until a {@link #flushCommands()} is
     * issued. After calling {@link #flushCommands()} commands are sent to the transport and executed by Redis.
     * 
     * @param autoFlush state of autoFlush.
     * 
     **/
    override suspend fun setAutoFlushCommands(autoFlush: Boolean): Unit? = ops.setAutoFlushCommands(autoFlush)

    /**
     * Flush pending commands. This commands forces a flush on the channel and can be used to buffer ("pipeline") commands to
     * achieve batching. No-op if channel is not connected.
     * 
     **/
    override suspend fun flushCommands(): Unit? = ops.flushCommands()

}


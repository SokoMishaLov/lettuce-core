/*
 * Copyright 2017-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("unused")

package io.lettuce.core.api.coroutines.async

import kotlinx.coroutines.future.await
import io.lettuce.core.api.coroutines.*
import io.lettuce.core.sentinel.api.coroutines.*
import io.lettuce.core.api.async.*
import io.lettuce.core.sentinel.api.async.*
import io.lettuce.core.ExperimentalLettuceCoroutinesApi
import io.lettuce.core.ScanArgs
import io.lettuce.core.ScanCursor
import io.lettuce.core.StreamScanCursor
import io.lettuce.core.ValueScanCursor
import io.lettuce.core.output.ValueStreamingChannel


/**
 * Coroutine executed commands (based on async commands) for Sets.
 * 
 * @param <K> Key type.
 * @param <V> Value type.
 * @author Mikhael Sokolov
 * @since 6.0
 * 
 * @generated by io.lettuce.apigenerator.CreateKotlinCoroutinesAsyncImplementation
 **/
@ExperimentalLettuceCoroutinesApi
internal class RedisSetSuspendableAsyncCommands<K, V>(private val ops: RedisSetAsyncCommands<K, V>) : RedisSetSuspendableCommands<K, V> {

    /**
     * Add one or more members to a set.
     * 
     * @param key the key.
     * @param members the member type: value.
     * @return Long integer-reply the number of elements that were added to the set, not including all the elements already
     *         present into the set.
     * 
     **/
    override suspend fun sadd(key: K?, vararg members: V?): Long? = ops.sadd(key, *members).await()

    /**
     * Get the number of members in a set.
     * 
     * @param key the key.
     * @return Long integer-reply the cardinality (number of elements) of the set, or {@code false} if {@code key} does not
     *         exist.
     * 
     **/
    override suspend fun scard(key: K?): Long? = ops.scard(key).await()

    /**
     * Subtract multiple sets.
     * 
     * @param keys the key.
     * @return Set<V> array-reply list with members of the resulting set.
     * 
     **/
    override suspend fun sdiff(vararg keys: K?): Set<V>? = ops.sdiff(*keys).await()

    /**
     * Subtract multiple sets.
     * 
     * @param channel the channel.
     * @param keys the keys.
     * @return Long count of members of the resulting set.
     * 
     **/
    override suspend fun sdiff(channel: ValueStreamingChannel<V>?, vararg keys: K?): Long? = ops.sdiff(channel, *keys).await()

    /**
     * Subtract multiple sets and store the resulting set in a key.
     * 
     * @param destination the destination type: key.
     * @param keys the key.
     * @return Long integer-reply the number of elements in the resulting set.
     * 
     **/
    override suspend fun sdiffstore(destination: K?, vararg keys: K?): Long? = ops.sdiffstore(destination, *keys).await()

    /**
     * Intersect multiple sets.
     * 
     * @param keys the key.
     * @return Set<V> array-reply list with members of the resulting set.
     * 
     **/
    override suspend fun sinter(vararg keys: K?): Set<V>? = ops.sinter(*keys).await()

    /**
     * Intersect multiple sets.
     * 
     * @param channel the channel.
     * @param keys the keys.
     * @return Long count of members of the resulting set.
     * 
     **/
    override suspend fun sinter(channel: ValueStreamingChannel<V>?, vararg keys: K?): Long? = ops.sinter(channel, *keys).await()

    /**
     * Intersect multiple sets and store the resulting set in a key.
     * 
     * @param destination the destination type: key.
     * @param keys the key.
     * @return Long integer-reply the number of elements in the resulting set.
     * 
     **/
    override suspend fun sinterstore(destination: K?, vararg keys: K?): Long? = ops.sinterstore(destination, *keys).await()

    /**
     * Determine if a given value is a member of a set.
     * 
     * @param key the key.
     * @param member the member type: value.
     * @return Boolean integer-reply specifically:
     * 
     *         {@code true} if the element is a member of the set. {@code false} if the element is not a member of the set, or
     *         if {@code key} does not exist.
     * 
     **/
    override suspend fun sismember(key: K?, member: V?): Boolean? = ops.sismember(key, member).await()

    /**
     * Move a member from one set to another.
     * 
     * @param source the source key.
     * @param destination the destination type: key.
     * @param member the member type: value.
     * @return Boolean integer-reply specifically:
     * 
     *         {@code true} if the element is moved. {@code false} if the element is not a member of {@code source} and no
     *         operation was performed.
     * 
     **/
    override suspend fun smove(source: K?, destination: K?, member: V?): Boolean? = ops.smove(source, destination, member).await()

    /**
     * Get all the members in a set.
     * 
     * @param key the key.
     * @return Set<V> array-reply all elements of the set.
     * 
     **/
    override suspend fun smembers(key: K?): Set<V>? = ops.smembers(key).await()

    /**
     * Get all the members in a set.
     * 
     * @param channel the channel.
     * @param key the keys.
     * @return Long count of members of the resulting set.
     * 
     **/
    override suspend fun smembers(channel: ValueStreamingChannel<V>?, key: K?): Long? = ops.smembers(channel, key).await()

    /**
     * Remove and return a random member from a set.
     * 
     * @param key the key.
     * @return V bulk-string-reply the removed element, or {@code null} when {@code key} does not exist.
     * 
     **/
    override suspend fun spop(key: K?): V? = ops.spop(key).await()

    /**
     * Remove and return one or multiple random members from a set.
     * 
     * @param key the key.
     * @param count number of members to pop.
     * @return V bulk-string-reply the removed element, or {@code null} when {@code key} does not exist.
     * 
     **/
    override suspend fun spop(key: K?, count: Long): Set<V>? = ops.spop(key, count).await()

    /**
     * Get one random member from a set.
     * 
     * @param key the key.
     * @return V bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply with the
     *         randomly selected element, or {@code null} when {@code key} does not exist.
     * 
     **/
    override suspend fun srandmember(key: K?): V? = ops.srandmember(key).await()

    /**
     * Get one or multiple random members from a set.
     * 
     * @param key the key.
     * @param count the count type: long.
     * @return Set<V> bulk-string-reply without the additional {@code count} argument the command returns a Bulk Reply
     *         with the randomly selected element, or {@code null} when {@code key} does not exist.
     * 
     **/
    override suspend fun srandmember(key: K?, count: Long): List<V>? = ops.srandmember(key, count).await()

    /**
     * Get one or multiple random members from a set.
     * 
     * @param channel streaming channel that receives a call for every value.
     * @param key the key.
     * @param count the count.
     * @return Long count of members of the resulting set.
     * 
     **/
    override suspend fun srandmember(channel: ValueStreamingChannel<V>?, key: K?, count: Long): Long? = ops.srandmember(channel, key, count).await()

    /**
     * Remove one or more members from a set.
     * 
     * @param key the key.
     * @param members the member type: value.
     * @return Long integer-reply the number of members that were removed from the set, not including non existing members.
     * 
     **/
    override suspend fun srem(key: K?, vararg members: V?): Long? = ops.srem(key, *members).await()

    /**
     * Add multiple sets.
     * 
     * @param keys the key.
     * @return Set<V> array-reply list with members of the resulting set.
     * 
     **/
    override suspend fun sunion(vararg keys: K?): Set<V>? = ops.sunion(*keys).await()

    /**
     * Add multiple sets.
     * 
     * @param channel streaming channel that receives a call for every value.
     * @param keys the keys.
     * @return Long count of members of the resulting set.
     * 
     **/
    override suspend fun sunion(channel: ValueStreamingChannel<V>?, vararg keys: K?): Long? = ops.sunion(channel, *keys).await()

    /**
     * Add multiple sets and store the resulting set in a key.
     * 
     * @param destination the destination type: key.
     * @param keys the key.
     * @return Long integer-reply the number of elements in the resulting set.
     * 
     **/
    override suspend fun sunionstore(destination: K?, vararg keys: K?): Long? = ops.sunionstore(destination, *keys).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param key the key.
     * @return ValueScanCursor<V> scan cursor.
     * 
     **/
    override suspend fun sscan(key: K?): ValueScanCursor<V>? = ops.sscan(key).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param key the key.
     * @param scanArgs scan arguments.
     * @return ValueScanCursor<V> scan cursor.
     * 
     **/
    override suspend fun sscan(key: K?, scanArgs: ScanArgs?): ValueScanCursor<V>? = ops.sscan(key, scanArgs).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param key the key.
     * @param scanCursor cursor to resume from a previous scan, must not be {@code null}.
     * @param scanArgs scan arguments.
     * @return ValueScanCursor<V> scan cursor.
     * 
     **/
    override suspend fun sscan(key: K?, scanCursor: ScanCursor?, scanArgs: ScanArgs?): ValueScanCursor<V>? = ops.sscan(key, scanCursor, scanArgs).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param key the key.
     * @param scanCursor cursor to resume from a previous scan, must not be {@code null}.
     * @return ValueScanCursor<V> scan cursor.
     * 
     **/
    override suspend fun sscan(key: K?, scanCursor: ScanCursor?): ValueScanCursor<V>? = ops.sscan(key, scanCursor).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param channel streaming channel that receives a call for every value.
     * @param key the key.
     * @return StreamScanCursor scan cursor.
     * 
     **/
    override suspend fun sscan(channel: ValueStreamingChannel<V>?, key: K?): StreamScanCursor? = ops.sscan(channel, key).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param channel streaming channel that receives a call for every value.
     * @param key the key.
     * @param scanArgs scan arguments.
     * @return StreamScanCursor scan cursor.
     * 
     **/
    override suspend fun sscan(channel: ValueStreamingChannel<V>?, key: K?, scanArgs: ScanArgs?): StreamScanCursor? = ops.sscan(channel, key, scanArgs).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param channel streaming channel that receives a call for every value.
     * @param key the key.
     * @param scanCursor cursor to resume from a previous scan, must not be {@code null}.
     * @param scanArgs scan arguments.
     * @return StreamScanCursor scan cursor.
     * 
     **/
    override suspend fun sscan(channel: ValueStreamingChannel<V>?, key: K?, scanCursor: ScanCursor?, scanArgs: ScanArgs?): StreamScanCursor? = ops.sscan(channel, key, scanCursor, scanArgs).await()

    /**
     * Incrementally iterate Set elements.
     * 
     * @param channel streaming channel that receives a call for every value.
     * @param key the key.
     * @param scanCursor cursor to resume from a previous scan, must not be {@code null}.
     * @return StreamScanCursor scan cursor.
     * 
     **/
    override suspend fun sscan(channel: ValueStreamingChannel<V>?, key: K?, scanCursor: ScanCursor?): StreamScanCursor? = ops.sscan(channel, key, scanCursor).await()

}


/*
 * Copyright 2017-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("unused")

package io.lettuce.core.api.coroutines.async

import kotlinx.coroutines.future.await
import io.lettuce.core.api.coroutines.*
import io.lettuce.core.sentinel.api.coroutines.*
import io.lettuce.core.api.async.*
import io.lettuce.core.sentinel.api.async.*
import io.lettuce.core.ExperimentalLettuceCoroutinesApi
import io.lettuce.core.BitFieldArgs
import io.lettuce.core.KeyValue
import io.lettuce.core.SetArgs
import io.lettuce.core.StrAlgoArgs
import io.lettuce.core.StringMatchResult
import io.lettuce.core.output.KeyValueStreamingChannel


/**
 * Coroutine executed commands (based on async commands) for Strings.
 * 
 * @param <K> Key type.
 * @param <V> Value type.
 * @author Mikhael Sokolov
 * @since 6.0
 * 
 * @generated by io.lettuce.apigenerator.CreateKotlinCoroutinesAsyncImplementation
 **/
@ExperimentalLettuceCoroutinesApi
internal class RedisStringSuspendableAsyncCommands<K, V>(private val ops: RedisStringAsyncCommands<K, V>) : RedisStringSuspendableCommands<K, V> {

    /**
     * Append a value to a key.
     * 
     * @param key the key.
     * @param value the value.
     * @return Long integer-reply the length of the string after the append operation.
     * 
     **/
    override suspend fun append(key: K?, value: V?): Long? = ops.append(key, value).await()

    /**
     * Count set bits in a string.
     * 
     * @param key the key.
     * @return Long integer-reply The number of bits set to 1.
     * 
     **/
    override suspend fun bitcount(key: K?): Long? = ops.bitcount(key).await()

    /**
     * Count set bits in a string.
     * 
     * @param key the key.
     * @param start the start.
     * @param end the end.
     * @return Long integer-reply The number of bits set to 1.
     * 
     **/
    override suspend fun bitcount(key: K?, start: Long, end: Long): Long? = ops.bitcount(key, start, end).await()

    /**
     * Execute {@code BITFIELD} with its subcommands.
     * 
     * @param key the key.
     * @param bitFieldArgs the args containing subcommands, must not be {@code null}.
     * @return Long bulk-reply the results from the bitfield commands.
     * 
     **/
    override suspend fun bitfield(key: K?, bitFieldArgs: BitFieldArgs?): List<Long>? = ops.bitfield(key, bitFieldArgs).await()

    /**
     * Find first bit set or clear in a string.
     * 
     * @param key the key.
     * @param state the state.
     * @return Long integer-reply The command returns the position of the first bit set to 1 or 0 according to the request.
     * 
     *         If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is
     *         returned.
     * 
     *         If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns
     *         the first bit not part of the string on the right. So if the string is tree bytes set to the value 0xff the
     *         command {@code BITPOS key 0} will return 24, since up to bit 23 all the bits are 1.
     * 
     *         Basically the function consider the right of the string as padded with zeros if you look for clear bits and
     *         specify no range or the <em>start</em> argument <strong>only</strong>.
     * 
     **/
    override suspend fun bitpos(key: K?, state: Boolean): Long? = ops.bitpos(key, state).await()

    /**
     * Find first bit set or clear in a string.
     * 
     * @param key the key.
     * @param state the bit type: long.
     * @param start the start type: long.
     * @return Long integer-reply The command returns the position of the first bit set to 1 or 0 according to the request.
     * 
     *         If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is
     *         returned.
     * 
     *         If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns
     *         the first bit not part of the string on the right. So if the string is tree bytes set to the value 0xff the
     *         command {@code BITPOS key 0} will return 24, since up to bit 23 all the bits are 1.
     * 
     *         Basically the function consider the right of the string as padded with zeros if you look for clear bits and
     *         specify no range or the <em>start</em> argument <strong>only</strong>.
     * @since 5.0.1
     * 
     **/
    override suspend fun bitpos(key: K?, state: Boolean, start: Long): Long? = ops.bitpos(key, state, start).await()

    /**
     * Find first bit set or clear in a string.
     * 
     * @param key the key.
     * @param state the bit type: long.
     * @param start the start type: long.
     * @param end the end type: long.
     * @return Long integer-reply The command returns the position of the first bit set to 1 or 0 according to the request.
     * 
     *         If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is
     *         returned.
     * 
     *         If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns
     *         the first bit not part of the string on the right. So if the string is tree bytes set to the value 0xff the
     *         command {@code BITPOS key 0} will return 24, since up to bit 23 all the bits are 1.
     * 
     *         Basically the function consider the right of the string as padded with zeros if you look for clear bits and
     *         specify no range or the <em>start</em> argument <strong>only</strong>.
     * 
     *         However this behavior changes if you are looking for clear bits and specify a range with both
     *         <strong>start</strong> and <strong>end</strong>. If no clear bit is found in the specified range, the function
     *         returns -1 as the user specified a clear range and there are no 0 bits in that range.
     * 
     **/
    override suspend fun bitpos(key: K?, state: Boolean, start: Long, end: Long): Long? = ops.bitpos(key, state, start, end).await()

    /**
     * Perform bitwise AND between strings.
     * 
     * @param destination result key of the operation.
     * @param keys operation input key names.
     * @return Long integer-reply The size of the string stored in the destination key, that is equal to the size of the longest
     *         input string.
     * 
     **/
    override suspend fun bitopAnd(destination: K?, vararg keys: K?): Long? = ops.bitopAnd(destination, *keys).await()

    /**
     * Perform bitwise NOT between strings.
     * 
     * @param destination result key of the operation.
     * @param source operation input key names.
     * @return Long integer-reply The size of the string stored in the destination key, that is equal to the size of the longest
     *         input string.
     * 
     **/
    override suspend fun bitopNot(destination: K?, source: K?): Long? = ops.bitopNot(destination, source).await()

    /**
     * Perform bitwise OR between strings.
     * 
     * @param destination result key of the operation.
     * @param keys operation input key names.
     * @return Long integer-reply The size of the string stored in the destination key, that is equal to the size of the longest
     *         input string.
     * 
     **/
    override suspend fun bitopOr(destination: K?, vararg keys: K?): Long? = ops.bitopOr(destination, *keys).await()

    /**
     * Perform bitwise XOR between strings.
     * 
     * @param destination result key of the operation.
     * @param keys operation input key names.
     * @return Long integer-reply The size of the string stored in the destination key, that is equal to the size of the longest
     *         input string.
     * 
     **/
    override suspend fun bitopXor(destination: K?, vararg keys: K?): Long? = ops.bitopXor(destination, *keys).await()

    /**
     * Decrement the integer value of a key by one.
     * 
     * @param key the key.
     * @return Long integer-reply the value of {@code key} after the decrement.
     * 
     **/
    override suspend fun decr(key: K?): Long? = ops.decr(key).await()

    /**
     * Decrement the integer value of a key by the given number.
     * 
     * @param key the key.
     * @param amount the decrement type: long.
     * @return Long integer-reply the value of {@code key} after the decrement.
     * 
     **/
    override suspend fun decrby(key: K?, amount: Long): Long? = ops.decrby(key, amount).await()

    /**
     * Get the value of a key.
     * 
     * @param key the key.
     * @return V bulk-string-reply the value of {@code key}, or {@code null} when {@code key} does not exist.
     * 
     **/
    override suspend fun get(key: K?): V? = ops.get(key).await()

    /**
     * Returns the bit value at offset in the string value stored at key.
     * 
     * @param key the key.
     * @param offset the offset type: long.
     * @return Long integer-reply the bit value stored at <em>offset</em>.
     * 
     **/
    override suspend fun getbit(key: K?, offset: Long): Long? = ops.getbit(key, offset).await()

    /**
     * Get a substring of the string stored at a key.
     * 
     * @param key the key.
     * @param start the start type: long.
     * @param end the end type: long.
     * @return V bulk-string-reply.
     * 
     **/
    override suspend fun getrange(key: K?, start: Long, end: Long): V? = ops.getrange(key, start, end).await()

    /**
     * Set the string value of a key and return its old value.
     * 
     * @param key the key.
     * @param value the value.
     * @return V bulk-string-reply the old value stored at {@code key}, or {@code null} when {@code key} did not exist.
     * 
     **/
    override suspend fun getset(key: K?, value: V?): V? = ops.getset(key, value).await()

    /**
     * Increment the integer value of a key by one.
     * 
     * @param key the key.
     * @return Long integer-reply the value of {@code key} after the increment.
     * 
     **/
    override suspend fun incr(key: K?): Long? = ops.incr(key).await()

    /**
     * Increment the integer value of a key by the given amount.
     * 
     * @param key the key.
     * @param amount the increment type: long.
     * @return Long integer-reply the value of {@code key} after the increment.
     * 
     **/
    override suspend fun incrby(key: K?, amount: Long): Long? = ops.incrby(key, amount).await()

    /**
     * Increment the float value of a key by the given amount.
     * 
     * @param key the key.
     * @param amount the increment type: double.
     * @return Double bulk-string-reply the value of {@code key} after the increment.
     * 
     **/
    override suspend fun incrbyfloat(key: K?, amount: Double): Double? = ops.incrbyfloat(key, amount).await()

    /**
     * Get the values of all the given keys.
     * 
     * @param keys the key.
     * @return List<V> array-reply list of values at the specified keys.
     * 
     **/
    override suspend fun mget(vararg keys: K?): List<KeyValue<K, V>>? = ops.mget(*keys).await()

    /**
     * Stream over the values of all the given keys.
     * 
     * @param channel the channel.
     * @param keys the keys.
     * @return Long array-reply list of values at the specified keys.
     * 
     **/
    override suspend fun mget(channel: KeyValueStreamingChannel<K, V>?, vararg keys: K?): Long? = ops.mget(channel, *keys).await()

    /**
     * Set multiple keys to multiple values.
     * 
     * @param map the null.
     * @return String simple-string-reply always {@code OK} since {@code MSET} can't fail.
     * 
     **/
    override suspend fun mset(map: Map<K, V>?): String? = ops.mset(map).await()

    /**
     * Set multiple keys to multiple values, only if none of the keys exist.
     * 
     * @param map the null.
     * @return Boolean integer-reply specifically:
     * 
     *         {@code 1} if the all the keys were set. {@code 0} if no key was set (at least one key already existed).
     * 
     **/
    override suspend fun msetnx(map: Map<K, V>?): Boolean? = ops.msetnx(map).await()

    /**
     * Set the string value of a key.
     * 
     * @param key the key.
     * @param value the value.
     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
     * 
     **/
    override suspend fun set(key: K?, value: V?): String? = ops.set(key, value).await()

    /**
     * Set the string value of a key.
     * 
     * @param key the key.
     * @param value the value.
     * @param setArgs the setArgs.
     * @return String simple-string-reply {@code OK} if {@code SET} was executed correctly.
     * 
     **/
    override suspend fun set(key: K?, value: V?, setArgs: SetArgs?): String? = ops.set(key, value, setArgs).await()

    /**
     * Sets or clears the bit at offset in the string value stored at key.
     * 
     * @param key the key.
     * @param offset the offset type: long.
     * @param value the value type: string.
     * @return Long integer-reply the original bit value stored at <em>offset</em>.
     * 
     **/
    override suspend fun setbit(key: K?, offset: Long, value: Int): Long? = ops.setbit(key, offset, value).await()

    /**
     * Set the value and expiration of a key.
     * 
     * @param key the key.
     * @param seconds the seconds type: long.
     * @param value the value.
     * @return String simple-string-reply.
     * 
     **/
    override suspend fun setex(key: K?, seconds: Long, value: V?): String? = ops.setex(key, seconds, value).await()

    /**
     * Set the value and expiration in milliseconds of a key.
     * 
     * @param key the key.
     * @param milliseconds the milliseconds type: long.
     * @param value the value.
     * @return String simple-string-reply.
     * 
     **/
    override suspend fun psetex(key: K?, milliseconds: Long, value: V?): String? = ops.psetex(key, milliseconds, value).await()

    /**
     * Set the value of a key, only if the key does not exist.
     * 
     * @param key the key.
     * @param value the value.
     * @return Boolean integer-reply specifically:
     * 
     *         {@code 1} if the key was set {@code 0} if the key was not set.
     * 
     **/
    override suspend fun setnx(key: K?, value: V?): Boolean? = ops.setnx(key, value).await()

    /**
     * Overwrite part of a string at key starting at the specified offset.
     * 
     * @param key the key.
     * @param offset the offset type: long.
     * @param value the value.
     * @return Long integer-reply the length of the string after it was modified by the command.
     * 
     **/
    override suspend fun setrange(key: K?, offset: Long, value: V?): Long? = ops.setrange(key, offset, value).await()

    /**
     * The STRALGO command implements complex algorithms that operate on strings. This method uses the LCS algorithm (longest
     * common substring).
     * 
     * <ul>
     * <li>Without modifiers the string representing the longest common substring is returned.</li>
     * <li>When {@link StrAlgoArgs#justLen() LEN} is given the command returns the length of the longest common substring.</li>
     * <li>When {@link StrAlgoArgs#withIdx() IDX} is given the command returns an array with the LCS length and all the ranges
     * in both the strings, start and end offset for each string, where there are matches. When
     * {@link StrAlgoArgs#withMatchLen() WITHMATCHLEN} is given each array representing a match will also have the length of the
     * match.</li>
     * </ul>
     * 
     * @param strAlgoArgs command arguments.
     * @return StringMatchResult.
     * @since 6.0
     * 
     **/
    override suspend fun stralgoLcs(strAlgoArgs: StrAlgoArgs?): StringMatchResult? = ops.stralgoLcs(strAlgoArgs).await()

    /**
     * Get the length of the value stored in a key.
     * 
     * @param key the key.
     * @return Long integer-reply the length of the string at {@code key}, or {@code 0} when {@code key} does not exist.
     * 
     **/
    override suspend fun strlen(key: K?): Long? = ops.strlen(key).await()

}

